// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/dipper-iot/dipper-engine-server/graph/model"
	"github.com/dipper-iot/dipper-engine-server/models"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Chan() ChanResolver
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Chan struct {
		CreatedAt   func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		Infinite    func(childComplexity int) int
		Name        func(childComplexity int) int
		RootNode    func(childComplexity int) int
		Status      func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
	}

	ListChan struct {
		List  func(childComplexity int) int
		Total func(childComplexity int) int
	}

	Mutation struct {
		CreateChan         func(childComplexity int, input model.InputChan) int
		DeleteChan         func(childComplexity int, id uint64) int
		UpdateChan         func(childComplexity int, id uint64, input model.InputChan) int
		UpdateRootNodeChan func(childComplexity int, id uint64, rootNode string) int
		UpdateStatusChan   func(childComplexity int, input model.SetStatusChan) int
		Version            func(childComplexity int) int
	}

	Query struct {
		GetChan  func(childComplexity int, id uint64) int
		ListChan func(childComplexity int, input models.ListChanRequest) int
		Version  func(childComplexity int) int
	}

	Version struct {
		Version func(childComplexity int) int
	}
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Chan.created_at":
		if e.complexity.Chan.CreatedAt == nil {
			break
		}

		return e.complexity.Chan.CreatedAt(childComplexity), true

	case "Chan.description":
		if e.complexity.Chan.Description == nil {
			break
		}

		return e.complexity.Chan.Description(childComplexity), true

	case "Chan.id":
		if e.complexity.Chan.ID == nil {
			break
		}

		return e.complexity.Chan.ID(childComplexity), true

	case "Chan.infinite":
		if e.complexity.Chan.Infinite == nil {
			break
		}

		return e.complexity.Chan.Infinite(childComplexity), true

	case "Chan.name":
		if e.complexity.Chan.Name == nil {
			break
		}

		return e.complexity.Chan.Name(childComplexity), true

	case "Chan.root_node":
		if e.complexity.Chan.RootNode == nil {
			break
		}

		return e.complexity.Chan.RootNode(childComplexity), true

	case "Chan.status":
		if e.complexity.Chan.Status == nil {
			break
		}

		return e.complexity.Chan.Status(childComplexity), true

	case "Chan.updated_at":
		if e.complexity.Chan.UpdatedAt == nil {
			break
		}

		return e.complexity.Chan.UpdatedAt(childComplexity), true

	case "ListChan.list":
		if e.complexity.ListChan.List == nil {
			break
		}

		return e.complexity.ListChan.List(childComplexity), true

	case "ListChan.total":
		if e.complexity.ListChan.Total == nil {
			break
		}

		return e.complexity.ListChan.Total(childComplexity), true

	case "Mutation.CreateChan":
		if e.complexity.Mutation.CreateChan == nil {
			break
		}

		args, err := ec.field_Mutation_CreateChan_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateChan(childComplexity, args["input"].(model.InputChan)), true

	case "Mutation.DeleteChan":
		if e.complexity.Mutation.DeleteChan == nil {
			break
		}

		args, err := ec.field_Mutation_DeleteChan_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteChan(childComplexity, args["id"].(uint64)), true

	case "Mutation.UpdateChan":
		if e.complexity.Mutation.UpdateChan == nil {
			break
		}

		args, err := ec.field_Mutation_UpdateChan_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateChan(childComplexity, args["id"].(uint64), args["input"].(model.InputChan)), true

	case "Mutation.UpdateRootNodeChan":
		if e.complexity.Mutation.UpdateRootNodeChan == nil {
			break
		}

		args, err := ec.field_Mutation_UpdateRootNodeChan_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateRootNodeChan(childComplexity, args["id"].(uint64), args["rootNode"].(string)), true

	case "Mutation.UpdateStatusChan":
		if e.complexity.Mutation.UpdateStatusChan == nil {
			break
		}

		args, err := ec.field_Mutation_UpdateStatusChan_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateStatusChan(childComplexity, args["input"].(model.SetStatusChan)), true

	case "Mutation.version":
		if e.complexity.Mutation.Version == nil {
			break
		}

		return e.complexity.Mutation.Version(childComplexity), true

	case "Query.GetChan":
		if e.complexity.Query.GetChan == nil {
			break
		}

		args, err := ec.field_Query_GetChan_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetChan(childComplexity, args["id"].(uint64)), true

	case "Query.ListChan":
		if e.complexity.Query.ListChan == nil {
			break
		}

		args, err := ec.field_Query_ListChan_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListChan(childComplexity, args["input"].(models.ListChanRequest)), true

	case "Query.version":
		if e.complexity.Query.Version == nil {
			break
		}

		return e.complexity.Query.Version(childComplexity), true

	case "Version.version":
		if e.complexity.Version.Version == nil {
			break
		}

		return e.complexity.Version.Version(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputInputChan,
		ec.unmarshalInputListChanRequest,
		ec.unmarshalInputSetStatusChan,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/schema.graphqls", Input: `# GraphQL schema example
#
# https://gqlgen.com/getting-started/

scalar Uint64
scalar Map

type Version {
    version: String!
}

type Query {
    version: Version!
}


type Mutation {
    version: Version!
}
`, BuiltIn: false},
	{Name: "../schema/chan/chan.mutation.graphql", Input: `extend type Mutation {
    CreateChan(input: InputChan!): Boolean!
    UpdateChan(id: Uint64!, input: InputChan!): Boolean!
    UpdateStatusChan(input: SetStatusChan!): Boolean!
    UpdateRootNodeChan(id: Uint64!, rootNode: String!): Boolean!
    DeleteChan(id: Uint64!): Boolean!
}`, BuiltIn: false},
	{Name: "../schema/chan/chan.query.graphql", Input: `extend type Query {
    ListChan(input: ListChanRequest!): ListChan!
    GetChan(id: Uint64!): Chan!
}`, BuiltIn: false},
	{Name: "../schema/chan/chan.type.graphql", Input: `type Chan {
    id: Uint64!
    name: String!
    description: String
    root_node: String
    infinite: Boolean
    status: ChanStatus
    created_at: String
    updated_at: String
}

enum ChanStatus {
    Activated
    Deactivated
}

type ListChan {
    total: Int!
    list: [Chan]
}

input ListChanRequest {
    skip: Int!
    limit: Int!
}

input InputChan {
    name: String!
    description: String
}

input SetStatusChan {
    id: ID!
    status: ChanStatus
}`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
